# 解決メソッドに直接オブジェクトを渡す

依存関係を解決したいクラスのコンストラクタに、それを生成する直前まで入手できないようなデータを与えたい場合があります。
その場合、ファクトリー定義内の解決メソッドに引数を与えることができます。

以下はユーザーの書くコードです。

```csharp
using System;
using Deprovgen.Annotations;
using UseDeprovgen.Infra;

namespace UseDeprovgen.Samples.Parameterize
{
	class Service
	{
		public void Say()
		{
			Console.WriteLine("It's Service!");
		}
	}

	class Client
	{
		private readonly Service _service;
		private readonly int _repeat;

		public Client(Service service, int repeat)
		{
			_service = service;
			_repeat = repeat;
		}

		public void Run()
		{
			Console.WriteLine("# Client");
			for (int i = 0; i < _repeat; i++)
			{
				_service.Say();
			}
		}
	}

	[Factory]
	interface IFactory
	{
		Service ResolveService();
		Client ResolveClient(int repeat);
	}

	class ParameterizeSample : ISample
	{
		public void Run()
		{
			var factory = new Factory();
			factory.ResolveClient(4).Run();
			factory.Dispose();
		}
	}
}
```

以下は生成されるコードです。

```csharp
// <autogenerated />
using System;
using System.Collections.Generic;

namespace UseDeprovgen.Samples.Parameterize
{
    internal partial class Factory : IFactory
        , IDisposable
    {

        private Service? _ResolveServiceCache;
        private Client? _ResolveClientCache;

        public Factory()
        {
        }

        public Service ResolveService()
        {
            return _ResolveServiceCache ??= new Service();
        }

        public Client ResolveClient(Int32 repeat)
        {
            return _ResolveClientCache ??= new Client(ResolveService(), repeat);
        }


        
        public void Dispose()
        {
        }
    }
}
```

実行結果は以下の通りです。

```
# Client
It's Service!
It's Service!
It's Service!
It's Service!
```
