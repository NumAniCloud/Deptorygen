# コレクションに対してインスタンスを注入する

以下はユーザーの書くコードです。

```csharp
using System;
using System.Collections.Generic;
using System.Text;
using Deprovgen.Annotations;
using UseDeprovgen.Infra;

namespace UseDeprovgen.Samples.Collection
{
	abstract class Service
	{
		public abstract void Do();
	}

	class ServiceA : Service
	{
		public override void Do()
		{
			Console.WriteLine("This is ServiceA");
		}
	}

	class ServiceB : Service
	{
		public override void Do()
		{
			Console.WriteLine("This is ServiceB");
		}
	}

	class ServiceC : Service
	{
		public override void Do()
		{
			Console.WriteLine("This is ServiceC");
		}
	}

	class Client
	{
		private readonly IEnumerable<Service> _services;

		public Client(IEnumerable<Service> services)
		{
			_services = services;
		}

		public void Invoke()
		{
			Console.WriteLine("# Client");
			foreach (var service in _services)
			{
				service.Do();
			}
		}
	}

	[Factory]
	interface IFactory
	{
		ServiceA ResolveServiceA();
		ServiceB ResolveServiceB();
		ServiceC ResolveServiceC();
		[Resolution(typeof(ServiceA))]
		[Resolution(typeof(ServiceB))]
		[Resolution(typeof(ServiceC))]
		IEnumerable<Service> ResolveServices();
		Client ResolveClient();
	}

	class CollectionSample : ISample
	{
		public void Run()
		{
			var factory = new Factory();
			factory.ResolveClient().Invoke();
		}
	}
}
```

生成されるソースコードは以下の通りです。

```csharp
// <autogenerated />
using System;
using System.Collections.Generic;

namespace UseDeprovgen.Samples.Collection
{
    internal partial class Factory : IFactory
        , IDisposable
    {

        private ServiceA? _ResolveServiceACache;
        private ServiceB? _ResolveServiceBCache;
        private ServiceC? _ResolveServiceCCache;
        private Client? _ResolveClientCache;

        public Factory()
        {
        }

        public ServiceA ResolveServiceA()
        {
            return _ResolveServiceACache ??= new ServiceA();
        }

        public ServiceB ResolveServiceB()
        {
            return _ResolveServiceBCache ??= new ServiceB();
        }

        public ServiceC ResolveServiceC()
        {
            return _ResolveServiceCCache ??= new ServiceC();
        }

        public Client ResolveClient()
        {
            return _ResolveClientCache ??= new Client(ResolveServices());
        }

        public IEnumerable<Service> ResolveServices()
        {
            return new Service[]
            {
                ResolveServiceA(),
				ResolveServiceB(),
				ResolveServiceC()
            };
        }

        
        public void Dispose()
        {
        }
    }
}
```

実行結果は以下の通りです。

```
# Client
This is ServiceA
This is ServiceB
This is ServiceC
```

## 課題

依存関係を解決できない場合にコンストラクタの引数としてインスタンスを要求すべき

コレクションに注入するための記述が冗長？
一般的なDIコンテナではひとつの抽象に対して複数の具象を注入したように書ける。
以下のような感じ

```csharp
interface IFactory
{
	[Resolution(typeof(ServiceB))]
	[Resolution(typeof(ServiceA))]
	[Resolution(typeof(ServiceC))]
	IService ResolveService();
	Client ResolveClient();
}
```
