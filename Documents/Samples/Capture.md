# 依存関係の解決に別のファクトリーも利用する(キャプチャ)

## 概要

別のファクトリーをプロパティとして持たせ、ファクトリーが依存関係を解決する際にプロパティに持っているファクトリーに解決を委譲することができます。

この機能は例えば、特定のファクトリーをインスタンス化する際にアプリ内の全ての依存関係を解決するだけの情報が収集できない場合などに便利です。

新たな情報が収集できたタイミングで新たなファクトリーをインスタンス化し、
その新たなファクトリーが元のファクトリーをプロパティとして持つようにすれば、
元のファクトリーが保持しているキャッシュなども引き継ぐことができます。

これが**キャプチャ**という機能です。

## サンプル

以下はユーザーの書くコードです。

```csharp
using System;
using Deptorygen.Annotations;
using UseDeptorygen.Infra;

namespace UseDeptorygen.Samples.Capture
{
	class Service
	{
		public void Call()
		{
			Console.WriteLine("Its Service.");
		}
	}

	class Service2
	{
		public void Say()
		{
			Console.WriteLine("Its Service2!");
		}
	}

	class Client
	{
		private readonly Service _service;
		private readonly Service2 _service2;

		public Client(Service service, Service2 service2)
		{
			_service = service;
			_service2 = service2;
		}

		public void Run()
		{
			Console.WriteLine("# Client");
			_service.Call();
			_service2.Say();
		}
	}

	[Factory]
	interface IBaseFactory
	{
		Service ResolveService();
		[Resolution(typeof(CaptureFactory))]
		ICaptureFactory ResolveCaptureFactory(Service2 service2);
	}

	[Factory]
	interface ICaptureFactory
	{
		// ここでファクトリー定義の IBaseFactory を"キャプチャ"する
		IBaseFactory BaseFactory { get; }
		Client ResolveClient();
	}

	class CaptureSample : ISample
	{
		public void Run()
		{
			var baseFactory = new BaseFactory();
			baseFactory.ResolveCaptureFactory(new Service2())
				.ResolveClient()
				.Run();;
		}
	}
}
```

生成されるソースコード `BaseFactory.g.cs` は以下の通りです。

```csharp
// <autogenerated />
using System;
using System.Collections.Generic;

namespace UseDeptorygen.Samples.Capture
{
    internal partial class BaseFactory : IBaseFactory
        , IDisposable
    {

        private Service? _ResolveServiceCache;
        private CaptureFactory? _ResolveCaptureFactoryCache;

        public BaseFactory()
        {
        }

        public Service ResolveService()
        {
            return _ResolveServiceCache ??= new Service();
        }

        public ICaptureFactory ResolveCaptureFactory(Service2 service2)
        {
            return _ResolveCaptureFactoryCache ??= new CaptureFactory(service2, this);
        }


        
        public void Dispose()
        {
			// ファクトリーは常に IDisposable なので、破棄するためのコードが生成される
            _ResolveCaptureFactoryCache?.Dispose();
        }
    }
}
```

生成されるソースコード `CaptureFactory.g.cs` は以下の通りです。

```csharp
// <autogenerated />
using System;
using System.Collections.Generic;

namespace UseDeptorygen.Samples.Capture
{
    internal partial class CaptureFactory : ICaptureFactory
        , IDisposable
    {
        private readonly Service2 _service2;
        public IBaseFactory BaseFactory { get; }

        private Client? _ResolveClientCache;

        public CaptureFactory(Service2 service2, IBaseFactory baseFactory)
        {
            _service2 = service2;
            BaseFactory = baseFactory;
        }

        public Client ResolveClient()
        {
            return _ResolveClientCache ??= new Client(BaseFactory.ResolveService(), _service2);
        }


        
        public void Dispose()
        {
        }
    }
}
```

`CaptureFactory.ResolveService`メソッドにて、`Client`クラスを解決するために`Service`クラスが必要ですが、
そこを`IBaseFactory`インターフェースの持つメソッドを利用して解決しています。

実行結果は以下の通りです。

```
# Client
Its Service.
Its Service2!
```

キャプチャを用いると、必要なファクトリー インターフェースは生成されたクラスのコンストラクタの引数として要求されます。

そのため、コンストラクタの引数にCodeFixで生成されたクラスではなく`IBaseFactory`を実装した自作のクラスを渡すこともできます。
キャプチャをそのように利用すると、インスタンスを生成する手順をカスタマイズすることができます。
