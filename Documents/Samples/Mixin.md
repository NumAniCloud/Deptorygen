# 他のファクトリー定義を取り込む(ミックスイン)

## 概要

以下のような2つのインターフェースがあったとします。

```csharp
interface IFactoryX
{
	Service ResolveService();
	ClientA ResolveClientA();
}

interface IFactoryY
{
	Service ResolveService();
	ClientA ResolveClientA();
	Service2 ResolveService2();
	ClientB ResolveClientB();	
}
```

`IFactoryY`インターフェースは、`IFactoryX`インターフェースに定義されているメソッドを全て含んでいます。
このような場合C#では、以下のようにインターフェースがインターフェースを継承するような形で定義することが多いです。

```csharp
interface IFactoryY : IFactoryX
{
	// IFactoryY インターフェースで特有のメソッドだけを定義する
	Service2 ResolveService2();
	ClientB ResolveClientB();
}
```

Deprovgenではこの書き方をファクトリー定義に利用することができます。
要するに、インターフェースを実装するときは通常その基底インターフェースも考慮する必要があるので、Deprovgenの生成するファクトリーもそうするということです。

## サンプル

```csharp
using System;
using Deprovgen.Annotations;
using UseDeprovgen.Infra;

namespace UseDeprovgen.Samples.Mixin
{
	class Service
	{
		public void Tell()
		{
			Console.WriteLine("Its Service.");
		}
	}

	class Service2
	{
		public void Say()
		{
			Console.WriteLine("That's Service2!");
		}
	}

	class ClientA
	{
		private readonly Service _service;

		public ClientA(Service service)
		{
			_service = service;
		}

		public void Invoke()
		{
			Console.WriteLine("# ClientA");
			_service.Tell();
		}
	}

	class ClientB
	{
		private readonly Service2 _service2;

		public ClientB(Service2 service2)
		{
			_service2 = service2;
		}

		public void Execute()
		{
			Console.WriteLine("# ClientB");
			_service2.Say();
		}
	}

	[Factory]
	interface IBaseFactory
	{
		Service ResolveService();
		ClientA ResolveClientA();
	}

	// このインターフェースは、IBaseFactoryインターフェースの定義するメソッドも含む
	[Factory]
	interface IMixinFactory : IBaseFactory
	{
		Service2 ResolveService2();
		ClientB ResolveClientB();
	}

	class MixinSample : ISample
	{
		public void Run()
		{
			var baseFactory = new BaseFactory();
			baseFactory.ResolveClientA().Invoke();
			baseFactory.Dispose();

			// 生成されたMixinFactoryは、生成されたBaseFactoryの機能も持つ
			var mixinFactory = new MixinFactory();
			mixinFactory.ResolveClientA().Invoke();
			mixinFactory.ResolveClientB().Execute();
			mixinFactory.Dispose();
		}
	}
}
```

生成される `BaseFactory.g.cs` は以下の通りです。

```csharp
// <autogenerated />
using System;
using System.Collections.Generic;

namespace UseDeprovgen.Samples.Mixin
{
    internal partial class BaseFactory : IBaseFactory
        , IDisposable
    {

        private Service? _ResolveServiceCache;
        private ClientA? _ResolveClientACache;

        public BaseFactory()
        {
        }

        public Service ResolveService()
        {
            return _ResolveServiceCache ??= new Service();
        }

        public ClientA ResolveClientA()
        {
            return _ResolveClientACache ??= new ClientA(ResolveService());
        }


        
        public void Dispose()
        {
        }
    }
}
```

生成される `MixinFactory.g.cs` は以下の通りです。

```csharp
// <autogenerated />
using System;
using System.Collections.Generic;

namespace UseDeprovgen.Samples.Mixin
{
    internal partial class MixinFactory : IMixinFactory
        , IDisposable
    {

        private Service2? _ResolveService2Cache;
        private ClientB? _ResolveClientBCache;
        private Service? _ResolveServiceCache;
        private ClientA? _ResolveClientACache;

        public MixinFactory()
        {
        }

        public Service2 ResolveService2()
        {
            return _ResolveService2Cache ??= new Service2();
        }

        public ClientB ResolveClientB()
        {
            return _ResolveClientBCache ??= new ClientB(ResolveService2());
        }

        public Service ResolveService()
        {
            return _ResolveServiceCache ??= new Service();
        }

        public ClientA ResolveClientA()
        {
            return _ResolveClientACache ??= new ClientA(ResolveService());
        }


        
        public void Dispose()
        {
        }
    }
}
```

実行結果は以下の通りです。

```
# ClientA
Its Service.
# ClientA
Its Service.
# ClientB
That's Service2!
```
