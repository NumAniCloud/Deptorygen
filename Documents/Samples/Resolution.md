# インターフェースを戻り値として、実際には実装を返す

古典的なDIコンテナでは、例えばコンストラクタでインターフェース型の変数を引数に取るクラスがあると、
そこへインターフェースを実装したインスタンスを注入する機能を持ちます。

なので、Deptorygenでもそれが可能です。

以下はユーザーの書くコードです。

```csharp
using System;
using Deptorygen.Annotations;
using UseDeptorygen.Infra;

namespace UseDeptorygen.Samples.Resolution
{
	class ServiceGold : IService
	{
		public void Say()
		{
			Console.WriteLine("This is gold.");
		}
	}

	class Client
	{
		private readonly IService _service;

		public Client(IService service)
		{
			_service = service;
		}

		public void Run()
		{
			Console.WriteLine("# Client");
			_service.Say();
		}
	}

	interface IService
	{
		void Say();
	}

	[Factory]
	interface IFactory
	{
		[Resolution(typeof(ServiceGold))]
		IService ResolveService();

		Client ResolveClient();
	}

	class ResolutionSample : ISample
	{
		public void Run()
		{
			var factory = new Factory();
			factory.ResolveClient().Run();
		}
	}
}
```

この`IFactory`のように、`Resolution`属性をつけてその属性引数に具体的な型を書くと、
戻り値の中身としてその型を生成してくれます。

以下は生成されるコードです。

```csharp
// <autogenerated />
#nullable enable
using System;
using System.Collections.Generic;

namespace UseDeptorygen.Samples.Resolution
{
	internal partial class Factory : IFactory
		, IDisposable
	{
		private ServiceGold? _ResolveServiceCache;
		private Client? _ResolveClientCache;

		public Factory()
		{
		}

		public IService ResolveService()
		{
			return _ResolveServiceCache ??= new ServiceGold();
		}

		public Client ResolveClient()
		{
			return _ResolveClientCache ??= new Client(ResolveService());
		}

		public void Dispose()
		{
		}
	}
}
```

実行結果は以下の通りです。

```txt
# Client
This is gold.
```

`Resolution`属性を複数つけた場合にどれが選ばれるのかは今のところ未定義です。

また、`Resolution`属性のついたメソッドを持つファクトリー定義を別のファクトリー`MixinFactory`がミックスインしたとすると、
`MixinFactory`の対応するメソッドもまた同じ`Resolution`属性がついているものとして扱われます。
つまり、通常のインターフェースの継承と同じ感覚で使えるということです。