# 基本的な使い方

## 要求. 2つのクラス間の依存関係を解決したい

2つのクラスを生成するファクトリーを生成してみます。

この例では、誰にも依存しないクラス`Service`と、`Service`へ依存するクラス`Client`があります。
コードは以下のようになります。

```csharp
// Entries.cs
using System;

namespace UseDeptorygen.Guides.BasicStyle
{
	class Service
	{
		public void Do()
		{
			Console.WriteLine("Done.");
		}
	}

	class Client
	{
		private readonly Service _service;

		public Client(Service service)
		{
			_service = service;
		}

		public void Do()
		{
			Console.WriteLine("Doing.");
			_service.Do();
		}
	}
}
```

## Step1. ファクトリー定義の仮作成と、コード生成の実行

これらに対して依存関係を解決するファクトリーを生成したければ、まずはファクトリーを生成する種となるインターフェースを定義します。
まずは空の定義を作ってみましょう。

Deptorygenのファクトリーを生成するためのインターフェースを、これからは**ファクトリー定義**と呼ぶことにします。

```csharp
// Factory.cs
using Deptorygen.Annotations;

namespace UseDeptorygen.Guides.BasicStyle
{
	[Factory]
	interface IFactory
	{
	}
}
```

ここまで書いたあと、インターフェース名の宣言として書いた`IFactory`の辺りにマウスカーソルを合わせたときに、
クイックアクションを適用できることを示す💡マークが現れることを確認します。
💡をクリックすると、`Create Factory`というコマンドが表示されます。
このコマンドを実行すると、ファクトリークラスが生成されます。

このタイミングでファクトリークラスを生成すると、以下のようなクラスがコード生成されます。

```csharp
// Factory.g.cs
// <autogenerated />
#nullable enable
using System;
using System.Collections.Generic;

namespace UseDeptorygen.Guides.BasicStyle
{
	public partial class Factory : IFactory
		, IDisposable
	{
		public Factory()
		{
		}

		public void Dispose()
		{
		}
	}
}
```

元のインターフェースの名前が`IFactory`だったため、
そこから先頭の`I`を取り除いた`Factory`がクラス名となります。
いま`Factory`クラスは何も機能を持ちません。ファクトリー定義に何も書いていなかったので当然ですね。

それから、`Factory`という名前のクラスが作られると、ファイル名は`Factory.g.cs`となり、
ファクトリー定義の書かれたファイルと同じディレクトリに作成されます。

## Step2. 依存関係を解決する

それでは、ファクトリー定義の中身を書いていきましょう。

ファクトリーに`Service`クラスのインスタンスを生成してもらいたい場合、
ファクトリー定義に`Service`を戻り値とするメソッドを定義します。

ファクトリーに`Client`クラスのインスタンスを生成してもらいたい場合、
ファクトリー定義に`Client`を戻り値とするメソッドを定義します。

ふたつのクラスの生成メソッドを含むファクトリー定義は以下のようになります。

```csharp
using Deptorygen.Annotations;

namespace UseDeptorygen.Guides.BasicStyle
{
	[Factory]
	interface IFactory
	{
		Service ResolveService();
		Client ResolveClient();
	}
}
```

戻り値が`Service`のメソッド`ResolveService`と、
戻り値が`Client`のメソッド`ResolveClient`を作成しました。

この状態になると、先ほどコード生成した`Factory`クラス側ではコンパイルエラーが発生するはずです。
`Factory`クラスは`IFactory`インターフェースを実装しており、いま`IFactory`インターフェースの中身が変わったので、
`Factory`クラスは`IFactory`インターフェースとして必要なメソッドを実装していない状態になったのです。

こうしてエラーが出ることで、プログラマーはコード生成を再び実行する必要があることに気づくことができるのも
Deptorygenを利用する利点です。

それでは、`Create Facotry`コマンドでコード生成をした結果を紹介します。

```csharp
// <autogenerated />
#nullable enable
using System;
using System.Collections.Generic;

namespace UseDeptorygen.Guides.BasicStyle
{
	internal partial class Factory : IFactory
		, IDisposable
	{
		private Service? _ResolveServiceCache;
		private Client? _ResolveClientCache;

		public Factory()
		{
		}

		public Service ResolveService()
		{
			return _ResolveServiceCache ??= new Service();
		}

		public Client ResolveClient()
		{
			return _ResolveClientCache ??= new Client(ResolveService());
		}

		public void Dispose()
		{
		}
	}
}
```

以前といくつか変わった点があります。

今や`Factory`クラスは`ResolveService`メソッドと`ResolveClient`メソッドを実装するようになったため、
コンパイルエラーは出なくなりました。
当然、これらのメソッドを利用して`Service`,`Client`のインスタンスを生成することができるようになりました。

`ResolveService`の中では、`new Service()`という式で`Service`クラスのインスタンスを生成しています。

一方で`ResolveClient`の中でも`Client`クラスをnewしていますが、
コンストラクタ引数として`Service`を要求されているため、
そこを`ResolveService`メソッドを利用することで依存関係を解決しています。

また、ファクトリー内で生成したインスタンスはキャッシュされ、次に解決する際は同じものが返されます。

## 補足

ファクトリー定義をもう一度見てみましょう。

```csharp
using Deptorygen.Annotations;

namespace UseDeptorygen.Guides.BasicStyle
{
	[Factory]
	interface IFactory
	{
		Service ResolveService();
		Client ResolveClient();
	}
}
```

`Service`クラスのインスタンスを生成するメソッドの名前を`ResolveService`としていますが、
メソッド名を`Resolve+<型名>`とする、といったようなルールがDeptorygenにあるわけではありません。
メソッド名には自由な分かりやすい名前をつけてください。
