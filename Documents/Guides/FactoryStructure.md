# キャプチャ、ミックスイン、ファクトリーのファクトリー

## ファクトリーどうしの依存関係

Deptorygenで生成したファクトリーは、それらが2つ以上あるときにお互いに依存関係を持つ場合があります。
それらは以下のような種類があります：

### キャプチャ

あるファクトリーFactoryGoldが行うべき依存関係の解決を、別のファクトリーFactorySilverに委譲するための仕組みです。
この場合、FactoryGoldはFactorySilverの持つインターフェースIFactorySilverに依存します。
`FactorySilver`に直接依存したりはしません。

### ミックスイン

あるファクトリーFactoryGoldが、別のファクトリーFactorySilverの定義を全て取り込むための仕組みです。
つまり、FactorySilverで解決できるような依存関係は、全てFactoryGoldでも解決できる必要があると定義することになります。
FactoryGold が、FactorySilverの持つインターフェース`IFactorySilver`に依存します。
`FactorySilver`に直接依存したりはしません。

### ファクトリーのファクトリー

あるファクトリーFactoryGoldが、別のファクトリーFactorySilverを生成するようにファクトリー定義を書くことができます。
この場合、FactoryGoldはFactorySilverにもIFactorySilverにも依存します。

## どのような順番でコード生成を実行する？

キャプチャやミックスインを利用するとき、キャプチャする/される側、ミックスインする/される側に対して
コード生成を実行する順番はあまり重要ではありません。

ただし、ファクトリーを生成するファクトリーを生成したい場合は問題があります。

これらの問題はissueとして管理して、後で直したいとNumAniCloudは思っています。

### Case1. ファクトリーを生成するファクトリー

このケースではあまり大きな問題があるわけではありませんが、
注意すべき点があるので紹介します。

以下のようなクラス群があります。

```csharp
using System;

namespace UseDeptorygen.Guides.ResolveFactory
{
	class Service
	{
		public void Do()
		{
			Console.WriteLine("Done.");
		}
	}

	class Service2
	{
		public void Do()
		{
			Console.WriteLine("Doned.");
		}
	}

	class Client
	{
		private readonly Service _service;
		private readonly Service2 _service2;

		public Client(Service service, Service2 service2)
		{
			_service = service;
			_service2 = service2;
		}

		public void Do()
		{
			Console.WriteLine("Doing.");
			_service.Do();
			_service2.Do();
		}
	}
}
```

以下のようなファクトリー定義があります。
まだコード生成は実行しません。

```csharp
using Deptorygen.Annotations;

namespace UseDeptorygen.Guides.ResolveFactory
{
	[Factory]
	interface IFactoryGold
	{
		Client ResolveClient();
	}

	[Factory]
	interface IFactorySilver
	{
		Service ResolveService();
		[Resolution(typeof(FactoryGold))]
		IFactoryGold ResolveFactoryGold(Service2 service2);
	}
}
```

ここで、`IFactorySilver`インターフェースの`ResolveFactoryGold`メソッドに注目してください。
`Resolution`属性は、解決メソッドがその戻り値の派生型を返すようにしたい場合に使用します。
いまこの属性に`FactoryGold`クラスを与えていますが、`FactoryGold`はコード生成を実行するまで存在しないはずです。
そのため、`IFactoryGold`に対してコード生成を実行するまでの間、
この部分に対してコンパイルエラーが報告されるのを容認する必要があります。

もし、`IFactoryGold`より前に`IFactorySilver`に対してコード生成をするとどうなるでしょうか？
次のようなものが生成されます：

```csharp
// <autogenerated />
#nullable enable
using System;
using System.Collections.Generic;
using ;

namespace UseDeptorygen.Guides.ResolveFactory
{
	internal partial class FactorySilver : IFactorySilver
		, IDisposable
	{
		private Service? _ResolveServiceCache;
		private FactoryGold? _ResolveFactoryGoldCache;

		public FactorySilver()
		{
		}

		public Service ResolveService()
		{
			return _ResolveServiceCache ??= new Service();
		}

		public IFactoryGold ResolveFactoryGold(Service2 service2)
		{
			return _ResolveFactoryGoldCache ??= new FactoryGold();
		}

		public void Dispose()
		{
		}
	}
}
```

`using`の部分と、`FactoryGold`型を使っている部分でコンパイルエラーが発生します。
この後`IFactoryGold`からクラスを生成して、その後改めて`IFactorySilver`からクラスを生成すれば、このコンパイルエラーは解消します。

このように、ファクトリーを生成するファクトリーがある場合、コード生成の順番が重要です。
生成される側のファクトリーが先で、生成する側のファクトリーは後に生成する必要があります。

コンパイルエラーがあるので、この問題が起きていることに気づかないことはありませんが、
エラーを解消するのに苦労するかもしれないので紹介しました。
この点を改善する機能をいずれ追加するかもしれません。

でも、しないかもしれません、運用でいくらでもカバーできるのだとすれば……

## Case2. ミックスインがあり、かつファクトリーを生成する場合

以下のようなクラス群があるとします。

```csharp
using System;

namespace UseDeptorygen.Guides.MixinAndParent
{
	class Service
	{
		public void Do()
		{
			Console.WriteLine("Done.");
		}
	}

	class Service2
	{
		public void Do()
		{
			Console.WriteLine("Doned.");
		}
	}

	class Client
	{
		private readonly Service _service;
		private readonly Service2 _service2;

		public Client(Service service, Service2 service2)
		{
			_service = service;
			_service2 = service2;
		}

		public void Do()
		{
			Console.WriteLine("Doing.");
			_service.Do();
			_service2.Do();
		}
	}
}
```

以下のようにファクトリー定義を作ります。

```csharp
using Deptorygen.Annotations;

namespace UseDeptorygen.Guides.MixinAndParent
{
	[Factory]
	interface IFactoryGold : IFactorySilver
	{
		Client ResolveClient();
	}

	[Factory]
	interface IFactorySilver
	{
		Service ResolveService();
		[Resolution(typeof(FactoryGold))]
		IFactoryGold ResolveFactoryGold();
	}
}
```

`IFactorySilver`は`FactoryGold`を生成する責務があるので、
前節で紹介したとおり先に`FactoryGold`を生成するのが良いでしょう。

しかし、`IFactoryGold`からコードを生成すると以下のようになります。

```csharp
// <autogenerated />
#nullable enable
using System;
using System.Collections.Generic;
using ;

namespace UseDeptorygen.Guides.MixinAndParent
{
	internal partial class FactoryGold : IFactoryGold
		, IDisposable
	{
		private readonly Service2 _service2;

		private Client? _ResolveClientCache;
		private Service? _ResolveServiceCache;
		private FactoryGold? _ResolveFactoryGoldCache;

		public FactoryGold(Service2 service2)
		{
			_service2 = service2;
		}

		public Client ResolveClient()
		{
			return _ResolveClientCache ??= new Client(ResolveService(), _service2);
		}

		public Service ResolveService()
		{
			return _ResolveServiceCache ??= new Service();
		}

		public IFactoryGold ResolveFactoryGold()
		{
			return _ResolveFactoryGoldCache ??= new FactoryGold();
		}

		public void Dispose()
		{
		}
	}
}
```

`IFactoryGold`インターフェースは`IFactorySilver`インターフェースを実装するため、
`FactoryGold`クラスは自分自身(`FactoryGold`)も生成しなければなりません。

`FactoryGold.ResolveFactoryGold`メソッドにて、新たな`FactoryGold`インスタンスを生成する必要がありますが、
このコードを生成する前までは`FactoryGold`クラスが存在しなかったため、
`FactoryGold`のコンストラクタに何も渡しておらず、コンパイルエラーとなっています。

**この状態でもう一度IFactoryGoldからコード生成をすると、エラーは解消します。**

### 依存関係が変化した場合の問題

しかし、この`IFactoryGold`には他にも問題点があります。

いま、`Client`クラスの処理が変化して、`Service2`クラスを必要としなくなったと仮定しましょう。
新しい`Client`クラスは以下の通りです。

```csharp
namespace UseDeptorygen.Guides.MixinAndParent
{
	class Client
	{
		private readonly Service _service;

		public Client(Service service)
		{
			_service = service;
		}

		public void Do()
		{
			Console.WriteLine("Doing.");
			_service.Do();
		}
	}
}
```

この状態で`IFactoryGold`からコード生成をすると、以下のクラスが生成されます。

```csharp
// <autogenerated />
#nullable enable
using System;
using System.Collections.Generic;

namespace UseDeptorygen.Guides.MixinAndParent
{
	internal partial class FactoryGold : IFactoryGold
		, IDisposable
	{
		private readonly Service2 _service2;

		private Client? _ResolveClientCache;
		private Service? _ResolveServiceCache;
		private FactoryGold? _ResolveFactoryGoldCache;

		public FactoryGold(Service2 service2)
		{
			_service2 = service2;
		}

		public Client ResolveClient()
		{
			return _ResolveClientCache ??= new Client(ResolveService());
		}

		public Service ResolveService()
		{
			return _ResolveServiceCache ??= new Service();
		}

		public IFactoryGold ResolveFactoryGold()
		{
			return _ResolveFactoryGoldCache ??= new FactoryGold(_service2);
		}

		public void Dispose()
		{
			_ResolveFactoryGoldCache?.Dispose();
		}
	}
}
```

このコードにはコンパイルエラーはありません。
前と変わったのは主に、`Client`クラスの生成時に`_service2`フィールドを渡さなくなったことです。

良く見ると、`FactoryGold`が解決すべき依存関係には、`Service2`を要求するクラスがもう存在しません。
なのに、`FactoryGold`はいまだに`Service2`のインスタンスをコンストラクタで要求しています。

これは、`FactoryGold`自身が`Service2`のインスタンスを要求しているからです。
`_service2`フィールドは`ResolveFactoryGold`メソッドで要求されています。

これを解決するためには、`IFactorySilver`インターフェースから`ResolveFactoryGold`メソッドをコメントアウトし、
`FactoryGold`クラスを生成しなおしてから、`ResolveFactoryGold`メソッドのコメントを外し、
最後にもう一度`FactoryGold`クラスを生成します。

これは面倒で間違えやすい手順なので、早めに直したいところです。
