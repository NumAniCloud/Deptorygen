# Deprovgen サンプル集

## サンプルの読み方

以下のように定義された `ISample` クラスを利用します。
サンプルコードのエントリポイントとなるクラスは、 `ISample` を実装する必要があります。
これの`Run`メソッドが Main メソッドから呼ばれます。

```csharp
namespace UseDeprovgen.Infra
{
	interface ISample
	{
		void Run();
	}
}
```

また、生成されるコードとして紹介するプログラムにはコメントが入っている場合がありますが、これは実際に生成されるコードには入っていないコメントを紹介のために追加したものです。

## 基本の使い方

あるクラスが別のクラスをコンストラクタで要求しているとき、そこへオブジェクトを正しく与えるのは骨の折れる作業です。Deprovgenでファクトリークラスを生成すると、コンストラクタに何を渡せばよいか判断してくれます。

このサンプルでのシナリオはあまり有用なものではありませんが、Deprovgenの働きの基本を確認することができます。

以下はユーザーコードです。

```csharp
using System;
using UseDeprovgen.Infra;
using Deprovgen.Annotations;

namespace UseDeprovgen.Samples.Basic
{
    // Clientクラスにこのクラスを注入したい
	class Service
	{
		public void Show()
		{
			Console.WriteLine("This is Service!");
		}
	}

    // Serviceクラスをこのクラスへ注入したい
	class Client
	{
		private readonly Service _service;

		public Client(Service service)
		{
			_service = service;
		}

		public void Execute()
		{
			Console.WriteLine("# Client");
			_service.Show();
		}
	}

    // ファクトリーの定義。これをタネにDeprovgenの生成を走らせます
	[Factory]
	interface IFactory
	{
		Client ResolveClient();
	}

	class BasicSample : ISample
	{
        // ファクトリーの利用側
		public void Run()
		{
            // Factory というクラスが生成されるのでこう書く
            // もちろん、Factoryクラスが生成されてから書いても良い
			var factory = new Factory(new Service());
			factory.ResolveClient().Execute();
		}
	}
}
```

生成されるコードは以下の通りです。

```csharp
// <autogenerated />
using System;

namespace UseDeprovgen.Samples.Basic
{
    internal partial class Factory : IFactory
    {
        private readonly Service _service;

        // 一度生成したオブジェクトを再利用するためのキャッシュ
        private Client? _resolveClientCache;

        // 依存関係の解決に必要なオブジェクトはコンストラクタで渡す
        public Factory(Service service)
        {
            _service = service;
        }

        // このメソッドを呼べば、 Client クラスの依存関係が解決されて返される
        public Client ResolveClient()
        {
            // 生成したものをキャッシュしながら返す。
            // キャッシュしたものは、次に呼び出したときに再利用される
            return _resolveClientCache ??= new Client(_service);
        }
    }

}
```

実行結果は以下のようになります：

```
# Client
This is Service!
```

`BasicSample`クラスを見ての通り、ファクトリー自体に`Service`クラスのオブジェクトを与える必要があるため、`Client`クラスを直接生成するよりむしろコーディングの負担が高くなってしまっています。しかしこの問題について不安に思う必要がない理由のひとつは、これは依存関係の規模が小さいからということです。

不安に思う必要がないもうひとつの理由は、ファクトリーのコンストラクタに`Service`クラスのオブジェクトを渡さずに利用する方法もあることです。

## 解決したいオブジェクトの依存先も解決したい

このサンプルでは、`Service`クラスの生成もファクトリーに任せることで、ユーザーは`Service`についても`Client`についても、そのクラスの生成方法について考える責任から解放されることができます。

以下はユーザーの書くコードです。

```csharp
using System;
using Deprovgen.Annotations;
using UseDeprovgen.Infra;

namespace UseDeprovgen.Samples.BasicDependency
{
	class Service
	{
		public void Show()
		{
			Console.WriteLine("This is Service!");
		}
	}

	class Client
	{
		private readonly Service _service;

		public Client(Service service)
		{
			_service = service;
		}

		public void Execute()
		{
			Console.WriteLine("# Client");
			_service.Show();
		}
	}

	[Factory]
	interface IFactory
	{
        // Serviceクラスを解決してもらいたい
		Service ResolveService();
        // ClientクラスはServiceクラスに依存している。
        // これも解決してもらいたい
		Client ResolveClient();
	}

	class BasicDependencySample : ISample
	{
		public void Run()
		{
			// Factoryクラスのコンストラクタに引数がいらない
			var factory = new Factory();
			factory.ResolveClient().Execute();
		}
	}
}
```

生成されるコードは以下の通りです。

```csharp
// <autogenerated />
using System;

namespace UseDeprovgen.Samples.BasicDependency
{
    internal partial class Factory : IFactory
    {

        private Service? _resolveServiceCache;
        private Client? _resolveClientCache;

        public Factory()
        {
        }

        public Service ResolveService()
        {
            return _resolveServiceCache ??= new Service();
        }

        public Client ResolveClient()
        {
            return _resolveClientCache ??= new Client(ResolveService());
        }
    }

}
```

実行結果は以下の通りです。

```
# Client
This is Service!
```

## キャッシュできていることを確認

シングルトンパターンとして利用したいクラスは、ファクトリー内部にキャッシュして使いまわしてもらいたいと考えるでしょう。Deprovgenのファクトリーがオブジェクトを生成する場合、デフォルトでそのオブジェクトをキャッシュします。

以下はユーザーの書くコードです。

```csharp
using System;
using Deprovgen.Annotations;
using UseDeprovgen.Infra;

namespace UseDeprovgen.Samples.UseCache
{
	// このクラスが依存関係解決時にキャッシュされているか確かめたい
	class Service
	{
		private static int NextId = 0;

		private int Id { get; }

		public Service()
		{
			Id = NextId++;
		}

		public void Invoke()
		{
			Console.WriteLine($"This is Service #{Id}.");
		}
	}

	class Client
	{
		private readonly Service _serviceA;
		private readonly Service _serviceB;

		public Client(Service serviceA, Service serviceB)
		{
			_serviceA = serviceA;
			_serviceB = serviceB;
		}

		public void Say()
		{
			// キャッシュされていれば、2つのオブジェクトは同じIDを表示するはず
			_serviceA.Invoke();
			_serviceB.Invoke();
		}
	}

	// ファクトリー定義
	[Factory]
	interface IFactory
	{
		// Serviceクラスをファクトリーに定義しておかないとコンストラクタで要求されてしまう
		// その場合キャッシュと同じ効果はあるが、ここでは定義した場合のキャッシュを確かめたい
		Service ResolveService();
		Client ResolveClient();
	}

	class UseCacheSample : ISample
	{
		public void Run()
		{
			var factory = new Factory();
			factory.ResolveClient().Say();
		}
	}
}
```

以下は生成されるコードです。

```csharp
// <autogenerated />
using System;

namespace UseDeprovgen.Samples.UseCache
{
    internal partial class Factory : IFactory
    {

        private Service? _resolveServiceCache;
        private Client? _resolveClientCache;

        public Factory()
        {
        }

        public Service ResolveService()
        {
            return _resolveServiceCache ??= new Service();
        }

        public Client ResolveClient()
        {
            return _resolveClientCache ??= new Client(ResolveService(), ResolveService());
        }
    }

}
```

実行結果は以下の通りです。

```
This is Service #0.
This is Service #0.
```

注意点としては、Factoryクラス自体を新たに生成した場合、新たなFactoryクラスからServiceクラスを取得したならば、それはキャッシュから再利用されることはなく、新たにnewされます。なぜなら、元々あったFactoryクラスのキャッシュ変数とはスコープが切り離されているからです。

そのような状況は以下のように再現できます:

1. `Factory`クラスをnewする。(`factory1`とする)
2. `factory1`を用いて`Service`を生成する。(`service1`とする)
3. 新たな`Factory`クラスをnewする。(`factory2`とする) 
4. `factory2`を用いて`Service`を生成する。(`service2`とする)
5. `service1`と`service2`は別のインスタンスである。つまり、`service2`はキャッシュから再利用されたインスタンスではない。

このことは、シングルトン的な振る舞いはあるが完全にそうではない、すなわち文脈に応じて別々に扱いたいようなオブジェクトに対して利用できます。

例えば、HTTPリクエストを処理するアプリケーションでは、1つのリクエストの間においては常にアクセス可能で、しかしリクエストを処理し終われば破棄したいようなクラスを書くことがあり、そういった場合にファクトリーのスコープの仕組みを利用できます。

## 生成時にキャッシュしないようにしたい

ファクトリーから取得したいオブジェクトは、キャッシュしてほしいものばかりではありません。キャッシュを伴わずに依存関係を解決するオプションが用意されています。

以下はユーザーの書くコードです。

```csharp
using System;
using Deprovgen.Annotations;
using UseDeprovgen.Infra;

namespace UseDeprovgen.Samples.Transient
{
	// このクラスが依存関係解決時にキャッシュされないことを確かめたい
	class Service
	{
		private static int NextId = 0;

		private int Id { get; }

		public Service()
		{
			Id = NextId++;
		}

		public void Invoke()
		{
			Console.WriteLine($"This is Service #{Id}.");
		}
	}

	class Client
	{
		private readonly Service _serviceA;
		private readonly Service _serviceB;

		public Client(Service serviceA, Service serviceB)
		{
			_serviceA = serviceA;
			_serviceB = serviceB;
		}

		public void Say()
		{
			// キャッシュされていなければ、2つのオブジェクトは互いに異なるIDを表示するはず
			_serviceA.Invoke();
			_serviceB.Invoke();
		}
	}

	// ファクトリー定義
	[Factory]
	interface IFactory
	{
		// 解決メソッドの名前の末尾を "AsTransient" にするとキャッシュしないようになる
		Service ResolveServiceAsTransient();
		Client ResolveClient();
	}

	class TransientSample : ISample
	{
		public void Run()
		{
			var factory = new Factory();
			factory.ResolveClient().Say();
		}
	}
}
```

以下は生成されるコードです。

```csharp
// <autogenerated />
using System;

namespace UseDeprovgen.Samples.Transient
{
    internal partial class Factory : IFactory
    {

        private Client? _resolveClientCache;

        public Factory()
        {
        }

        public Service ResolveServiceAsTransient()
        {
            return new Service();
        }

        public Client ResolveClient()
        {
            return _resolveClientCache ??= new Client(ResolveServiceAsTransient(), ResolveServiceAsTransient());
        }
    }

}
```

実行結果は以下の通りです。

```
This is Service #0.
This is Service #1.
```

キャッシュするかどうかを、解決メソッドに対して属性を書くことで指定したい場合もあるかと思いますが、メソッド名はファクトリーを使用するプログラマーにとって重要であり、キャッシュをするのかどうかは常に名前から判別できるようDeprovgenは強制しています。

この機能が備わっている都合上、名前の末尾が `AsTransient` であるようなクラスの解決メソッドを定義したい場合、 `ResolveXXXAsTransientInstance` などというように `AsTransient` の後に別の文字を足さない限り、クラスはキャッシュしないものとしてコード生成が実行されてしまいますのでご注意ください。

## ファクトリーが自動で依存先クラスを生成する範囲をカスタマイズする

クライアントクラスに必要な依存先クラスが2つ以上あるとき、ファクトリーがその依存先を全て自分で生成することはできないとしても、自分で生成できるものまでコンストラクタを通じて要求してしまうのは望ましくありません。

なので、Deprovgenで生成したファクトリーは全ての依存先ではなく、自分では生成できない依存先のみをコンストラクタを通じて要求します。

以下はユーザーの書くコードです。

```csharp
using System;
using Deprovgen.Annotations;
using UseDeprovgen.Infra;

namespace UseDeprovgen.Samples.AutoAndManual
{
	// こちらはファクトリーで生成してもらう予定
	class ServiceSilver
	{
		public void Tell()
		{
			Console.WriteLine("I'm Silver.");
		}
	}

	// こちらはファクトリー外で自前で生成する予定
	class ServiceGold
	{
		public void Say()
		{
			Console.WriteLine("I'm Gold.");
		}
	}

	class Client
	{
		private readonly ServiceSilver _silver;
		private readonly ServiceGold _gold;

		public Client(ServiceSilver silver, ServiceGold gold)
		{
			_silver = silver;
			_gold = gold;
		}

		public void Invoke()
		{
			Console.WriteLine("# Client");
			_silver.Tell();
			_gold.Say();
		}
	}

	[Factory]
	interface IFactory
	{
		ServiceSilver ResolveServiceSilver();
		Client ResolveClient();
	}

	class AutoAndManualSample : ISample
	{
		public void Run()
		{
			var factory = new Factory(new ServiceGold());
			factory.ResolveClient().Invoke();
		}
	}
}
```

以下は生成されるコードです。

```csharp
// <autogenerated />
using System;

namespace UseDeprovgen.Samples.AutoAndManual
{
    internal partial class Factory : IFactory
    {
        private readonly ServiceGold _serviceGold;

        private ServiceSilver? _resolveServiceSilverCache;
        private Client? _resolveClientCache;

        public Factory(ServiceGold serviceGold)
        {
            _serviceGold = serviceGold;
        }

        public ServiceSilver ResolveServiceSilver()
        {
            return _resolveServiceSilverCache ??= new ServiceSilver();
        }

        public Client ResolveClient()
        {
            return _resolveClientCache ??= new Client(ResolveServiceSilver(), _serviceGold);
        }
    }

}
```

実行結果は以下の通りです。

```
# Client
I'm Silver.
I'm Gold.
```

`Factory`クラスのコンストラクタでは`ServiceGold`クラスのオブジェクトだけが要求され、一方で`ServiceSilver`クラスのオブジェクトはファクトリー自身が必要に応じて生成します。

これは、`IFactory`インターフェースとして書かれたファクトリー定義の中に`ServiceSilver`を取得するためのメソッドが含まれているためです。`ServiceGold`を取得するためのメソッドも用意したならば、`Factory`クラスのコンストラクタは引数が0個となります。

## 解決メソッドに直接オブジェクトを渡す

依存関係を解決したいクラスのコンストラクタに、それを生成する直前まで入手できないようなデータを与えたい場合があります。その場合、ファクトリー定義内の解決メソッドに引数を与えることができます。

### WIP

リゾルバーの引数に与えても、コンストラクタで要求してしまう状態になっている。
そもそも、同じ型の引数を複数与えた時の動作が保証されていないのでチェックが必要。

## 特定のファクトリーをベースにして新しいファクトリーを生成する

アプリが開始してから最初にファクトリーを生成するまでに、アプリの実行に必要な全ての情報が揃うことはあまりありません。
例えば、ユーザーがコマンドを入力した瞬間にそのコマンドを実行するようなアプリについて考えると、コマンドを入力されるまでは「ユーザーがどのコマンドを選ぼうとしているか」の情報を得ることができないはずです。

そのため、最初に生成したファクトリーだけではアプリで必要な依存関係を全て解決できない可能性があります。

そこで、特定のファクトリーによって解決できるオブジェクトや、ファクトリーが解決のために利用するオブジェクトを引き継いだ新たなファクトリーを生成することができます。
この機能は、アプリの実行中のある時点で新たな情報が収集できたタイミングに、新たな依存関係を解決できるよう新たなファクトリーをセットアップする目的に用います。

以下はユーザーの書くコードです。

* `ClientA` クラスは `Service` クラスを必要とします。
* `ClientB` クラスは `Service` クラス、 `Service2` クラスを両方とも必要とします。
* `IFactoryA` の実装クラスをnewするタイミングでは、 `Service2` を生成できるだけの情報が集まっていません。そこで、 `Service2` クラスを生成するための情報が集まった際に `IFactoryB` の実装クラスを新たにnewします。

```csharp
using System;
using Deprovgen.Annotations;
using UseDeprovgen.Infra;

namespace UseDeprovgen.Samples.FactoryProvider
{
	class Service
	{
		public void Say()
		{
			Console.WriteLine("This is Service");
		}
	}

	class Service2
	{
		public void Tell()
		{
			Console.WriteLine("This is Service 2");
		}
	}

	class ClientA
	{
		private readonly Service _service;

		public ClientA(Service service)
		{
			_service = service;
		}

		public void Execute()
		{
			Console.WriteLine("# ClientA");
			_service.Say();
		}
	}

	class ClientB
	{
		private readonly Service _service;
		private readonly Service2 _service2;

		public ClientB(Service service, Service2 service2)
		{
			_service = service;
			_service2 = service2;
		}

		public void Invoke()
		{
			Console.WriteLine("# ClientB");
			_service.Say();
			_service2.Tell();
		}
	}

	// ベースとなるファクトリー
	// 派生先のファクトリーの情報をこちらに書く
	// FactoryB クラスは生成されるコードなので、一度 IFactoryB をコード生成してか書く必要がある
	[Factory]
	[FactoryProvider(typeof(FactoryB))]
	interface IFactoryA
	{
		ClientA ResolveClientA();
	}

	// 派生したファクトリー
	// ベースとなるファクトリーが居なくても利用できるコードが生成される
	[Factory]
	interface IFactoryB
	{
		ClientB ResolveClientB();
	}

	class FactoryProviderSample : ISample
	{
		public void Run()
		{
			// 最初のファクトリーを生成する
			var factory = new FactoryA(new Service());
			factory.ResolveClientA().Execute();

			// サンプルコードなので、 Service2 クラスをnewできるだけの情報が集まった状況を仮定して Service2 を作成する
			var service2 = new Service2();

			// 最初のファクトリーの設定を受け継いで、新しいファクトリーを生成する
			var factoryB = factory.ResolveFactoryB(service2);
			factoryB.ResolveClientB().Invoke();
		}
	}
}
```

生成されるコード `FactoryA.g.cs` は以下の通りです。

```csharp
// <autogenerated />
using System;

namespace UseDeprovgen.Samples.FactoryProvider
{
    internal partial class FactoryA : IFactoryA
    {
        private readonly Service _service;

        private ClientA? _resolveClientACache;

        public FactoryA(Service service)
        {
            _service = service;
        }

        public ClientA ResolveClientA()
        {
            return _resolveClientACache ??= new ClientA(_service);
        }

        public FactoryB ResolveFactoryB(Service2 service2)
        {
            return new FactoryB(_service, service2);
        }
    }

    internal static class FactoryAExtensions
    {
        public static FactoryB ResolveFactoryB(this IFactoryA self, Service2 service2)
        {
            return self is FactoryA concrete ? concrete.ResolveFactoryB(service2)
                : throw new NotImplementedException("このメソッドは FactoryA クラスに対してのみ呼び出せます。");
        }
    }
}
```

生成されるコード `FactoryB.g.cs` は以下の通りです。

```csharp
// <autogenerated />
using System;

namespace UseDeprovgen.Samples.FactoryProvider
{
    internal partial class FactoryB : IFactoryB
    {
        private readonly Service _service;
        private readonly Service2 _service2;

        private ClientB? _resolveClientBCache;

        public FactoryB(Service service, Service2 service2)
        {
            _service = service;
            _service2 = service2;
        }

        public ClientB ResolveClientB()
        {
            return _resolveClientBCache ??= new ClientB(_service, _service2);
        }
    }

}
```

実行結果は以下の通りです。

```
# ClientA
This is Service
# ClientB
This is Service
This is Service 2
```

このサンプルでは、`FactoryA`が生成されるタイミングでは生成できないクラス`Service2`を、別のファクトリークラス`FactoryB`に生成させることにしました。

ただし、`FactoryB`を生成するときに`Service`クラスのインスタンスを改めて与えるのは冗長であるため、既に準備できている依存先のオブジェクトは`FactoryA`クラスのフィールドから引き継いでいます。

### 課題

サービスとしてオブジェクトを引数を通じて受け渡すと、受け渡したサービスは派生先のファクトリーではキャッシュされたもののように振る舞います。
しかし、そのオブジェクトが基となったファクトリーではTransientな解決メソッドで生成されていた場合、これは問題になります。キャッシュされていないと思っていたオブジェクトが実はキャッシュされている可能性があるためです。

これに対処する仕様として考えられる方法がいくつかあります。

#### ファクトリー定義の取り込みを利用する

後述の「他のファクトリー定義を取り込む」を利用すると、基となったファクトリーで解決できるようなものを、派生先のファクトリーが自分自身で解決するようになります。

これを利用しなければならないことが許容できるならば、Deprovgen側で追加の機能を用意する必要はありません。

#### 基底ファクトリーをコンストラクタで注入する

派生先のファクトリーのコンストラクタを通じて、基となるファクトリー自体を受け渡します。このファクトリーの解決メソッドを利用して、派生先のファクトリーが依存先を入手します。

これは生成されるクラスの構造が少々複雑になる、そしてユーザーが手動でnewしてファクトリーを利用したい場合に基となるファクトリーも全て手動で生成しなければならないなどのリスクがあります。特に後者のシナリオでは、基となるファクトリーからの依存先が派生先のファクトリーで全て必要になるわけではない場合に冗長です。

## 他のファクトリー定義を取り込む

以下のような2つのインターフェースがあったとします。

```csharp
interface IFactoryX
{
	Service ResolveService();
	ClientA ResolveClientA();
}

interface IFactoryY
{
	Service ResolveService();
	ClientA ResolveClientA();
	Service2 ResolveService2();
	ClientB ResolveClientB();	
}
```

`IFactoryY`インターフェースは、`IFactoryX`インターフェースに定義されているメソッドを全て含んでいます。このような場合C#では、以下のようにインターフェースがインターフェースを継承するような形で定義することが多いです。

```csharp
interface IFactoryY : IFactoryX
{
	// IFactoryY インターフェースで特有のメソッドだけを定義する
	Service2 ResolveService2();
	ClientB ResolveClientB();
}
```

Deprovgenではこの書き方をファクトリー定義に利用することができます。要するに、インターフェースを実装するときは通常その基底インターフェースも考慮する必要があるので、Deprovgenの生成するファクトリーもそうするということです。

### サンプル

```csharp
using System;
using Deprovgen.Annotations;
using UseDeprovgen.Infra;

namespace UseDeprovgen.Samples.Mixin
{
	class Service
	{
		public void Tell()
		{
			Console.WriteLine("Its Service.");
		}
	}

	class Service2
	{
		public void Say()
		{
			Console.WriteLine("That's Service2!");
		}
	}

	class ClientA
	{
		private readonly Service _service;

		public ClientA(Service service)
		{
			_service = service;
		}

		public void Invoke()
		{
			Console.WriteLine("# ClientA");
			_service.Tell();
		}
	}

	class ClientB
	{
		private readonly Service2 _service2;

		public ClientB(Service2 service2)
		{
			_service2 = service2;
		}

		public void Execute()
		{
			Console.WriteLine("# ClientB");
			_service2.Say();
		}
	}

	[Factory]
	interface IBaseFactory
	{
		Service ResolveService();
		ClientA ResolveClientA();
	}

	// このインターフェースは、IBaseFactoryインターフェースの定義するメソッドも含む
	[Factory]
	interface IMixinFactory : IBaseFactory
	{
		Service2 ResolveService2();
		ClientB ResolveClientB();
	}

	class MixinSample : ISample
	{
		public void Run()
		{
			IBaseFactory baseFactory = new BaseFactory();
			baseFactory.ResolveClientA().Invoke();

			// 生成されたMixinFactoryは、生成されたBaseFactoryの機能も持つ
			IMixinFactory mixinFactory = new MixinFactory();
			mixinFactory.ResolveClientA().Invoke();
			mixinFactory.ResolveClientB().Execute();
		}
	}
}
```

生成される `BaseFactory.g.cs` は以下の通りです。

```csharp
// <autogenerated />
using System;

namespace UseDeprovgen.Samples.Mixin
{
    internal partial class BaseFactory : IBaseFactory
    {

        private Service? _resolveServiceCache;
        private ClientA? _resolveClientACache;

        public BaseFactory()
        {
        }

        public Service ResolveService()
        {
            return _resolveServiceCache ??= new Service();
        }

        public ClientA ResolveClientA()
        {
            return _resolveClientACache ??= new ClientA(ResolveService());
        }
    }

}
```

生成される `MixinFactory.g.cs` は以下の通りです。

```csharp
// <autogenerated />
using System;

namespace UseDeprovgen.Samples.Mixin
{
    internal partial class MixinFactory : IMixinFactory
    {

        private Service2? _resolveService2Cache;
        private ClientB? _resolveClientBCache;
        private Service? _resolveServiceCache;
        private ClientA? _resolveClientACache;

        public MixinFactory()
        {
        }

        public Service2 ResolveService2()
        {
            return _resolveService2Cache ??= new Service2();
        }

        public ClientB ResolveClientB()
        {
            return _resolveClientBCache ??= new ClientB(ResolveService2());
        }

        public Service ResolveService()
        {
            return _resolveServiceCache ??= new Service();
        }

        public ClientA ResolveClientA()
        {
            return _resolveClientACache ??= new ClientA(ResolveService());
        }
    }

}
```

実行結果は以下の通りです。

```
# ClientA
Its Service.
# ClientA
Its Service.
# ClientB
That's Service2!
```

## 別のファクトリーからスコープも定義も受け継ぐ

前のいくつかの節で紹介した「特定のファクトリーをベースにして他のファクトリーを生成する」機能と「他のファクトリーの定義を取り込む」機能を組み合わせて使うことをお勧めします。

### サンプル

以下はユーザーの書くコードです。

```csharp
using System;
using Deprovgen.Annotations;
using UseDeprovgen.Infra;

namespace UseDeprovgen.Samples.FactoryInheritance
{
	// このクラスのインスタンスがキャッシュされていることを確認できるよう、IDを持たせている
	class Service
	{
		private static int NextId = 0;

		public int Id { get; }

		public Service()
		{
			Id = NextId++;
		}

		public void Say()
		{
			Console.WriteLine($"Hey Im Service #{Id}.");
		}
	}

	class Service2
	{
		public void Call()
		{
			Console.WriteLine("Hey Its Service2!");
		}
	}

	class ClientA
	{
		private readonly Service _service;

		public ClientA(Service service)
		{
			_service = service;
		}

		public void Run()
		{
			Console.WriteLine("# ClientA");
			_service.Say();
		}
	}

	class ClientB
	{
		private readonly Service _service;
		private readonly Service2 _service2;

		public ClientB(Service service, Service2 service2)
		{
			_service = service;
			_service2 = service2;
		}

		public void Work()
		{
			Console.WriteLine("# ClientB");
			_service.Say();
			_service2.Call();
		}
	}

	[Factory]
	[FactoryProvider(typeof(DerivedFactory))]
	interface IBaseFactory
	{
		Service ResolveServiceAsTransient();
		ClientA ResolveClientA();
	}

	[Factory]
	interface IDerivedFactory : IBaseFactory
	{
		ClientB ResolveClientB();
	}

	class FactoryInheritanceSample : ISample
	{
		public void Run()
		{
			IBaseFactory baseFactory = new BaseFactory();
			baseFactory.ResolveClientA().Run();

			IDerivedFactory derivedFactory = baseFactory.ResolveDerivedFactory(new Service2());
			derivedFactory.ResolveClientA().Run();
			derivedFactory.ResolveClientB().Work();
		}
	}
}
```

生成されるコード `BaseFactory.g.cs` は以下の通りです。

```csharp
// <autogenerated />
using System;

namespace UseDeprovgen.Samples.FactoryInheritance
{
    internal partial class BaseFactory : IBaseFactory
    {

        private ClientA? _resolveClientACache;

        public BaseFactory()
        {
        }

        public Service ResolveServiceAsTransient()
        {
            return new Service();
        }

        public ClientA ResolveClientA()
        {
            return _resolveClientACache ??= new ClientA(ResolveServiceAsTransient());
        }

        public DerivedFactory ResolveDerivedFactory(Service2 service2)
        {
            return new DerivedFactory(service2);
        }
    }

    internal static class BaseFactoryExtensions
    {
        public static DerivedFactory ResolveDerivedFactory(this IBaseFactory self, Service2 service2)
        {
            return self is BaseFactory concrete ? concrete.ResolveDerivedFactory(service2)
                : throw new NotImplementedException("このメソッドは BaseFactory クラスに対してのみ呼び出せます。");
        }
    }
}
```

生成されるコード `DerivedFactory.g.cs` は以下の通りです。

```csharp
// <autogenerated />
using System;

namespace UseDeprovgen.Samples.FactoryInheritance
{
    internal partial class DerivedFactory : IDerivedFactory
    {
        private readonly Service2 _service2;

        private ClientB? _resolveClientBCache;
        private ClientA? _resolveClientACache;

        public DerivedFactory(Service2 service2)
        {
            _service2 = service2;
        }

        public ClientB ResolveClientB()
        {
            return _resolveClientBCache ??= new ClientB(ResolveServiceAsTransient(), _service2);
        }

        public Service ResolveServiceAsTransient()
        {
            return new Service();
        }

        public ClientA ResolveClientA()
        {
            return _resolveClientACache ??= new ClientA(ResolveServiceAsTransient());
        }
    }

}
```

実行結果は以下の通りです。

```
# ClientA
Hey Im Service #0.
# ClientA
Hey Im Service #1.
# ClientB
Hey Im Service #2.
Hey Its Service2!
```

`DerivedFactory` クラス `Service` クラスのインスタンスを生成するときも、キャッシュされないように配慮されています。

単に `FactoryProvider` 属性を使うだけだった場合、 `Service` クラスのインスタンスは `DerivedFactory` クラスのコンストラクタを通じて保持され、キャッシュされている場合と同じ結果になったはずです。

そのため、インスタンスをキャッシュしないよう正しく制御したければ、ファクトリーの依存先を継承したい場合にはファクトリー定義も継承することをお勧めします。

## GenericHostと連携する

GenericHostはMicrosoftが提供している汎用的なフレームワークです。

汎用的な機能の中にはDIコンテナが含まれていますが、このDIコンテナはどんな依存関係も動的に解決しようとします。この方法は強力で、アセンブリから読み込まれている型であればどんな型の依存関係も解決することができます。

Deprovgenでは、どんな依存関係も静的に解決しようとします。しかし型どうしの依存関係は静的に解決できるものばかりではないため、動的なDIコンテナと併せて利用することをお勧めします。

Deprovgenでは、GenericHostによって依存関係の解決するときに、一部だけ静的に解決できるよう機能を拡張できます。

### サンプル

以下はユーザーの書くコードです。

```csharp
using System;
using Deprovgen.Annotations;
using Deprovgen.GenericHost;
using Microsoft.Extensions.DependencyInjection;
using UseDeprovgen.Infra;

namespace UseDeprovgen.Samples.GenericHost
{
	class Service
	{
		public void Tell()
		{
			Console.WriteLine("Wow its Service!");
		}
	}

	class Service2
	{
		public void Describe()
		{
			Console.WriteLine("It is Service2.");
		}
	}

	class Client
	{
		private readonly Service _service;
		private readonly Service2 _service2;

		public Client(Service service, Service2 service2)
		{
			_service = service;
			_service2 = service2;
		}

		public void Work()
		{
			Console.WriteLine("# Client");
			_service.Tell();
			_service2.Describe();
		}
	}

	// ConfigureGenericHost 属性をつけると、GenericHostで使えるようになる
	[Factory]
	[ConfigureGenericHost]
	interface IFactory
	{
		Service ResolveService();
		Service2 ResolveService2();
		Client ResolveClient();
	}

	class GenericHostSample : ISample
	{
		public void Run()
		{
			var services = new ServiceCollection();

			// GenericHost の ServiceCollection インスタンスに、ファクトリーのインスタンスを登録する
			services.UseDeprovgenFactory(new Factory());

			var serviceProvider = services.BuildServiceProvider();

			// Factory クラスで解決できる依存関係が、ServiceProvider からも解決できるようになる
			serviceProvider.GetService<Client>().Work();
		}
	}
}
```

以下は生成されるコードです。

```csharp
// <autogenerated />
using System;
using Deprovgen.GenericHost;
using Microsoft.Extensions.DependencyInjection;

namespace UseDeprovgen.Samples.GenericHost
{
    internal partial class Factory : IFactory
        , IDeprovgenFactory
    {

        private Service? _resolveServiceCache;
        private Service2? _resolveService2Cache;
        private Client? _resolveClientCache;

        public Factory()
        {
        }

        public Service ResolveService()
        {
            return _resolveServiceCache ??= new Service();
        }

        public Service2 ResolveService2()
        {
            return _resolveService2Cache ??= new Service2();
        }

        public Client ResolveClient()
        {
            return _resolveClientCache ??= new Client(ResolveService(), ResolveService2());
        }

		// このメソッドで GenericHost に依存関係の解決方法を登録する
        public void ConfigureServices(IServiceCollection services)
        {
			// Transientとして登録しているが、
			// インスタンスをファクトリー側でキャッシュしているため、
			// ユーザーはキャッシュされたインスタンスを受け取ることができる
            services.AddTransient<Service>(provider => ResolveService());
            services.AddTransient<Service2>(provider => ResolveService2());
            services.AddTransient<Client>(provider => ResolveClient());
        }
    }

}
```

実行結果は以下の通りです。

```
# Client
Wow its Service!
It is Service2.
```

### 課題

GenericHostにファクトリー自身も提供して、ServiceProviderを通じて静的な依存解決機能にアクセスできるようにしたい

## ファクトリー自体のアクセシビリティを制御する

ファクトリーが生成するクラスが全て `public` アクセシビリティを持つ型である場合に限り、生成されるファクトリークラス自体も `public` アクセシビリティを持って生成されます。
それ以外の場合は、ファクトリークラスは `internal` アクセシビリティを持ちます。

ちなみに、ファクトリークラスを別のクラスにネストした型として生成する手段はサポートされていないため、アクセシビリティとしても `private` などを付けることはありません。

## インターフェースに対して具象クラスでもって解決する

# Deprovgenに欲しい機能

## IEnumerable&lt;T> に対する注入

以下のようにして、解決可能なすべてのクラスを含むコレクションを取得できるようにしたい

```csharp
[Factory]
interface IFactory
{
	[Implementation(typeof(HogeSilver))]
	[Implementation(typeof(HogeGold))]
	IEnumerable<IHoge> ResolveHogeCollection();
}
```

## 生成方法のカスタマイズ

GenericHostの、ラムダ式に生成方法を記述する形式の登録方法のように、ユーザーが生成方法をカスタマイズできる手段が欲しい

どのような場面で使いたくなるかは検証しておくべき

ファクトリー定義インターフェースをコンストラクタを通じて注入することで、注入されたクラスがそのファクトリーの解決メソッドも活用して自身の依存関係解決を行うようにする？
そうすると、前述のFactoryProviderにおけるキャッシュ問題も解決され、生成方法のカスタマイズにも使えるかも（Code Fixを用いず、ユーザーが自由にファクトリーを実装して渡せばよい）

定義は以下のようになる？

```csharp
[FactoryProvider(typeof(DerivedFactory))]
interface IBaseFactory
{
}

[CaptureFactory(typeof(IBaseFactory))]
interface IDerivedFactory
{
}

// 生成結果
class DerivedFactory
{
	// baseFactoryのところに対して、BaseFactoryからthisが渡されてくる
	public DerivedFactory(IBaseFactory baseFactory)
	{
	}
}
```

||FactoryProvider + Mixin|ファクトリー定義の注入|
|-|-|-|
|キャッシュ問題|問題なし|問題なし|
|記述量|属性1 + 継承1|属性2|
|手動での生成のしやすさ|しやすい|しづらい|
|基となるファクトリーの解決メソッド|**継承する**|継承しない|
|解決方法のカスタマイズ|できない|**できる**|
|生成コードをアノテーションに用いる|用いる|用いる|

この手のカスタマイズは、Deprovgenでやりたいシナリオを「Deprovgenの機能を他者が使う」と「他者の機能をDeprovgenが使う」に分けたうちの後者なのかもしれない。
すなわち、ファクトリーを注入できるようにすればあらゆるカスタマイズができ、例えばGenericHostに依存関係を部分的に解決してもらうことなどもできる。

### ファクトリーのキャプチャ再考

ファクトリーのキャプチャがResolverと異なるところは、ファクトリーを生成するために追加で必要な依存先をコンストラクタで要求しないことである。

```csharp
class BaseFactory
{
	// DerivedFactory の生成には Service2 が必要だが、ここでは要求しない
	public BaseFactory(Service1 service1)
	{
	}

	// DerivedFactory を生成できるようになるために、引数リストもコード生成している
	public DerivedFactory GetDerivedFactory(Service2 service2)
	{
		return new DerivedFactory(_service1, service2);
	}
}
```

この方式には問題点がある：

* GetDerivedFactory メソッドの引数リストがコード生成まで定まらない。そのため、ファクトリー定義に書くことができず属性で指定する必要がある。

これを、ファクトリーを生成するためのファクトリー定義を通常の解決メソッドと同じ書き方にしてしまうとよいかもしれない。

```csharp
[Factory]
interface IBaseFactory
{
	Client ResolveClient();
	[Resolution(typeof(DerivedFactory))]
	IDerivedFactory GetDerivedFactory();
}
```

以下のように生成される。

```csharp
class BaseFactory
{
	public BaseFactory(Service2 service2) { /* ... */ }
	public Client ResolveClient() { /* キャッシュしながら生成 */ }
	public IDerivedFactory GetDerivedFactory()
	{
		return new DerivedFactory(this, _service2);
	} 
}
```

これでは困る部分があるが、それが仕様である。
困る部分とは、コンストラクタで`Service2`を要求してしまっていることであるが、標準の機能でこれは回避できる。ファクトリー定義で、手動で引数リストを書くのだ。

```csharp
[Factory]
interface IBaseFactory
{
	[Resolution(typeof(DerivedFactory))]
	IDerivedFactory GetDerivedFactory(Service2 service2);
}
```

以下のように生成される。

```csharp
class BaseFactory
{
	public BaseFactory() { /* ... */ }
	public Client ResolveClient() { /* キャッシュしながら生成 */ }
	public IDerivedFactory GetDerivedFactory(Service2 service2)
	{
		return new DerivedFactory(service2);
	}
}
```

すなわち、元の引数なしの解決メソッドで生成されるコードではユーザーが困るが、それにユーザーは容易に気づくことができることで良しとする。
ユーザーはコンストラクタで`Service2`インスタンスが要求されるのを避けたいと気づいたならば、それを`GetDerivedFactory`解決メソッドの引数に追加するだけでよい。

キャプチャする側は以下のように書く。

```csharp
[Factory]
interface IDerivedFactory : IBaseFactory
{
	ClientB ResolveClientB(Service2 service2);
}
```

これが以下のように生成される。

```csharp
class DerivedFactory : IDerivedFactory
{
	// IDerivedFactory が IBaseFactory を継承している場合に限り、
	// 引数に IBaseFactory を要求する
	public DerivedFactory(IBaseFactory baseFactory, Service2 service2)
	{
		/* 初期化 */
	}
	public Client ResolveClient()
	{
		// キャッシュも含めてキャプチャ元に頼る
		return _baseFactory.ResolveClient();
	}
	public ClientB ResolveClientB()
	{
		return _resolveClientBCache ??= new ClientB(ResolveClient(), _service2);
	}
}
```

このままでは `IBaseFactory` の定義には属性の引数として具象クラスが現れてしまうので、既約ベースで `I` を外した名前のクラスを優先して探すようにしてもよいかもしれない。
とはいえ、DIコンテナとは基本的に抽象と具象が同時に書かれる物なのでそれほど問題はないともいえる。

もしキャプチャー先ファクトリーに自作のファクトリーを注入したければ、`IBaseFactory`インターフェースを以下のように書けばよい：

```csharp
[Factory]
interface IBaseFactory
{
	[Resolution(typeof(DerivedFactory))]
	IDerivedFactory GetDerivedFactory(IBaseFactory baseFactory, Service2 service2);
}
```

こうすることで、`GetDerivedFactory`メソッドを呼び出すユーザー自身が`IBaseFactory`を実装するインスタンスを引数で与える責任を持つことになる。

総じて、この方法でファクトリーを生成する場合に通常の解決メソッドと異なる点は、キャプチャする側がキャプチャ元のファクトリーが持つ解決メソッドを利用するという点のみである。
コード生成としては、依存先インスタンスがファクトリーである場合にその解決メソッドを依存関係の解決手段として考慮に入れるための実装を必要とする。

それから、上記の他の案ではキャッシュがキャプチャ前後で別のスコープとなってしまっていたが、この方法では同じスコープとなる。

||FactoryProvider + Mixin|ファクトリー定義の注入|通常の解決として扱う|
|-|-|-|-|
|キャッシュ問題|問題あり|問題あり|問題なし|
|記述量|属性1 + 継承1|属性2|解決メソッド1 + 継承1|
|手動での生成のしやすさ|しやすい|しづらい|用途による|
|解決メソッドの継承|**継承する**|継承しない|**継承する**|
|解決方法のカスタマイズ|できない|**できる**|**できる**|
|定義に具象を含む|含む|含む|含む|

どれにせよ、Mixin自体は採用すべきであるはず。
ただ、インターフェースの継承関係があってもコンストラクタで要求したくない場合もありそうなので、その対処が必要。

### さらに再考：ミックスインとキャプチャの違い

```csharp
[Factory]
interface IBaseFactory : IFactoryToCapture
{
	[Resolution(typeof(DerivedFactory))]
	IDerivedFactory ResolveDerivedFactory();
}

[Factory]
// 継承を用いて、他のインターフェースをミックスインするか決める
interface IDerivedFactory : IFactoryToMixin
{
	// プロパティを用いて、他のインターフェースをキャプチャするか決める
	// キャプチャすると、コンストラクタでインスタンスを要求する
	// この方法で持っているファクトリー以外のファクトリーは、依存解決に利用しない
	IFactoryToCapture Captured { get; }
}
```

ミックスインはすでにある。

キャプチャは新規実装が必要。

FactoryProvider機能は削減してよさそう。

## オーバーロード解決について

今は戻り値だけで解決メソッドを区別しているが、他の基準が必要か？

キャプチャが絡むと、同じ戻り値を持つ解決メソッドが重複しうる。

また、同じサービスに対して複数の解決メソッドを用意するモチベーションがあるかどうかも考えておきたい。

キャプチャが重複していようと自分の中だけで重複していようとエラーにしてしまうという手もある。

## Deprovgenでは検証しないエラーを明確にする

コードが静的に生成されるため、依存解決ができない場合はコンパイルエラーとなる。これがDeprovgenの主な利点である。

コード生成自体ができない場合にのみ、Deprovgenはエラーを起こす。
その場合、Code Fix自体ができないようにするのが良いだろう。
それから、エラーが出る状況に関するドキュメントも欲しい。

生成できないエラーに対して、プレースホルダーのような生成を行って、コメントでエラーを表示するという手もあるかも

## 学習用のコメントを生成する

生成されたコードのいたるところに、「なぜそれが生成されたのか」を示すコメントを生成するようなモードがあるとよいかも？

## 用語の整理

説明としての用語と、クラス名の検討などが必要。

### 用語

* ファクトリー/Factory
* 解決メソッド/Resolver
* 依存関係の解決
	* 解決メソッドの戻り値を受け取ることに対して言う
* 依存関係の注入
	* 解決メソッドの中で行っていることに対して言う
* ファクトリー生成メソッド/Factory provider method
* その場限りのインスタンス/Transient instance
* キャッシュされるインスタンス/Cached instance
* ファクトリー定義/Factory definition
* ファクトリー定義の取り込み/ミックスイン/Factory definition mixin
* 依存先オブジェクト/Dependencies
	* あるファクトリーが、自身の解決メソッドで必要とするが解決メソッドでは生成できないオブジェクト。コンストラクタを通じて与える必要がある
* ファクトリーのキャプチャ/Facotry capturing
	* あるファクトリーが、他のファクトリーのファクトリー生成メソッドによって生成される時、前者のファクトリーが後者をキャプチャしているという。

する・される

* キャプチャーする
* キャプチャーされる
* ミックスインする
* ミックスインされる

### クラス名・メソッド名

属性

* Factory
* FactoryProvider
* ConfigureGenericHost
* Implementation
	* 1つのメソッドに複数つく可能性も考えると長い。`Resolution`とかがよい？

